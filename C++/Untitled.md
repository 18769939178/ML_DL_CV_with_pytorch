# 一、第一个C++程序

我们使用VS2022创建一个控制台应用

```c++
// 包含头文件。
#include <iostream>

// main函数，程序从这里开始执行，每个程序只能有一个main函数。
int main()
{
    // 在控制台输出一首诗。
    std::cout << "\n\n                        我是一只傻傻鸟\n";
    std::cout << "                   生活美好如鲜花，不懂享受是傻瓜；\n";
    std::cout << "                   傻呀傻呀傻呀傻，不如小鸟和乌鸦。\n";
    std::cout << "                   芳草地啊美如画，谁要不去是傻瓜；\n";
std::cout << "                   我是一只傻傻鸟，独在枯枝丫上趴。\n";

    // std::cout         向控制台输出内容的指令，只能小写，不能用大写。
    // <<              输出的运算符。
    // ""               字符串内容的边界符，半角。
    // Hello World!     输出字符串的内容，可以是中文、英文和任意符号，半角的双引号除外。
    // \n               输出一个换行。
    // ;                 C++语句结束的标志，半角。
}
```

同时，cout可以直接输出数字、字符和字符串，可以按照任意顺序拼接，比如说

```c++
cout << "你好!\n"<<100<<"hello"<<endl;
```

std::endl也可以用于换行；

using namespace std;指定缺省的命名空间。

# 二、注释

在程序中添加的说明文字，对代码的流程或功能加以解释，方便自己和其他的程序员阅读和理解代码。

编译器在编译源代码的时候，会忽略注释。

## 1 单行注释

用两根反斜线`//`打头，一般放在代码的上方，或者一行语句的末尾。

注意：字符串内容中的两根反斜线是内容的一部分，不是注释。

## 2 多行注释

从/*开始，到*/结束，把一些内容夹住。

注意：

- 字符串内容中的/*和*/是内容的一部分，不是注释
- `/*`和`*/`可以出现在一行代码的中间。

## 3 注释的注释

单行注释可以注释多行注释，多行注释也可以注释单行注释，但是，不建议使用。

## 4 VS中的快捷键

添加注释：Ctrl+k+c

取消注释：Ctrl+k+u

# 三、变量

变量是内存变量的简称，用于存放数据。

## 1 声明变量

变量在使用之前要先声明。

语法：数据类型 变量名

C++常用的数据类型有五种：整数（int）、浮点数（float和double）、字符（char）、字符串（string）和布尔（bool）。

变量在声明的时候可以赋初始值。

语法：数据类型 变量名=值

## 2 变量的赋值

语法：变量名=值

并且注意，变量名不能冲突，并且变量类型有限制，一个数据类型的变量不能存放其他种类的数据，但是变量可以重复使用和赋值，就像容器一样

注意，布尔型变量输出的时候，如果值是true，将显示1，false显示0。

# 四、常量

总有一些量是固定不变的，比如说圆周率等，这就是常量，常量是程序中固定不变的数据。

## 1 宏常量

一般在main函数的上面声明，通常用大写命名。

语法：#define 常量名 值

## 2 const修饰的变量

在程序的任何地方都可以声明。

语法：const 数据类型 常量名=值

修改常量会报错，无法进行编译

# 五、标识符命名

## 1 命名规则

C++规定给标识符（变量、常量、函数、结构体、类等）命名时，必须遵守以下规则。

- 在名称中只能使用字母字符、数字和下划线；
- 名称的第一个字符不能是数字；
- 名称区分大写字符与小写字符；
- 不能将C++关键字用作名称；
- 以下划线和大写字母打头的名称被保留给编译器及其使用的资源使用，如果违反了这一规则，会导致行为的不确定性。**最好不使用此方式**
- C++对名称的长度没有限制，但有些平台可能有长度限制（64字符）。
- C++提倡有一定含义的名称（望名知义）。

## 2 关键字

[关键字](https://baike.baidu.com/item/关键字/7105697)也叫[保留字](https://baike.baidu.com/item/保留字/7674788)，是C++预先保留的标识符。

每个C++关键字都有特殊的含义，用于声明[类型](https://baike.baidu.com/item/类型/5799843)、[对象](https://baike.baidu.com/item/对象/17158)、[函数](https://baike.baidu.com/item/函数/301912)、[命名空间](https://baike.baidu.com/item/命名空间/2887476)等，程序中不能声明与关键字同名的[标识符](https://baike.baidu.com/item/标识符/7105638)。

# 六、输入数据

程序输入数据的方式很多种，最简单的就是从控制台界面中输入，还有文件、数据库和网络等方法

最基本的就是cin从控制台界面输入数据

```c++
string name;
std::cin>>name;
```

这样就可以将控制台中输入的字符串存入到`name`变量中了

但是注意一下，bool型变量的值在计算机内部是0和1存储，所以在程序中，bool类型的值可以写成true/false，也可以写成0/1，其他的值会强制转换为1

同时，在cout时，bool类型变量只会显示0/1

并且，如果输入的数据与变量的数据类型不匹配，好会导致行为的不确定性

# 七、算术运算

- 整数进行除法运算时，如果分母为0，程序将异常退出，也就是退出代码不为0
- 浮点数进行除法运算时，如果分母为0.0，将得到inf（infinite，无穷大）；这是因为在计算机中，浮点数的取值没有绝对的0，只有无限小
- 两个整数进行除法运算时，将舍去小数部分，得到一个整数；
- 整数与浮点数进行除法运算时，得到的结果是浮点数；
- 进行除法运算时，在整数前面加(float)或(double)可以将整数转换为float或double类型；
- 取模运算只能用于整数（分母也不能为0）。

# 八、赋值运算

自增自减可以放在程序任何地方，但是会存在先进行运算后执行其他操作的情况，比如说++在前面就是先执行加加后执行其他操作

同时，还有一些神奇的赋值运算

| 运算符 |       示例        |                             描述                             |
| :----: | :---------------: | :----------------------------------------------------------: |
|   =    |       c=a+b       |               把右边操作数的值赋给左边操作数。               |
|   +=   |  c+=a相当于c=c+a  | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数。 |
|   -=   |  c-=a相当于c=c-a  | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数。 |
|  \*=   | c\*=a相当于c=c\*a | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数。 |
|   /=   |  c/=a相当于c=c/a  | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数。 |
|   %=   |  c%=a相当于c=c%a  | 求余数且赋值运算符，求两个操作数的模赋值给左边操作数，浮点数不适用取余数。 |

本质上就是书写上更简单的一些运算符

注意一下

- 字符串（string）只能使用等号（=）赋值，不能使用其它的赋值运算符；
- 浮点数不能使用%=运算符；
- 等号（=）赋值运算符可以连续使用；比如说`a=c=30`就是同时给两个变量赋值
- 如果赋值运算符两边操作数的数据类型不同，C++将自动转换数据类型，可能会损失精度，也可能超出取值范围，如果转换不成功，编译时会报错。

还有就是一些现代化使用方法，下面就是C++11标准初始化赋值

- 把值写在小括号中，等于号可以省略（C++标准）
  - `int a=(15);  // 声明变量a，初始化值为15。`
  - `int b(20);  // 声明变量b，初始化值为20。`
- 把值写在花括号中，等于号也可以省略（C++11标准），统一初始化列表。
  - `int a={15};  // 声明变量a，初始化值为15。`
  - `int b{20};  // 声明变量b，初始化值为20。`

这样可以提高开发效率

注意：在Linux平台下，编译需要加-std=c++11参数。

# 九、关系运算

C++中的关系运算只有以下几种

|   关系   | 数学的表示 | C++的表示 |
| :------: | :--------: | :-------: |
|   等于   |     =      |    ==     |
|  不等于  |     ≠      |    !=     |
|   小于   |     <      |     <     |
| 小于等于 |     ≤      |    <=     |
|   大于   |     >      |     >     |
| 大于等于 |     ≥      |    >=     |

这些用于比较两个表达式的值，运算的结果为1-true和0-false。并且运算优先级高于赋值，比如说`result=a==b`结果是ab是否相等，但是不建议使用这种方法

注意：

- 关系运算符的两边可以是数值，也可以是表达式；
- 用`std::cout`输出关系运算表达式时，关系表达式要加括号，否则会报错
- 关系运算也适用于字符串（string），字符串常用的关系运算是`==`和`!=`，其它的基本上不用。

此外还有逻辑运算，也就是根据给定的逻辑因子（表达式或值）返回一个新的逻辑因子。

| 运算符 |     术语     |  示例   |                            结果                            |
| :----: | :----------: | :-----: | :--------------------------------------------------------: |
|   &&   |    逻辑与    |  a&&b;  |           如果a和b都为真，则结果为真，否则为假。           |
|  \|\|  |    逻辑或    | a\|\|b; | 如果a和b中有一个为真，则结果为真，二者都为假时，结果为假。 |
|   !    | 逻辑非（反） |   !a;   |        如果a为假，则!a为真； 如果a为真，则!a为假。         |

注意：

- 逻辑运算符的两边可以是数值，也可以是表达式；
- 用std::cout输出逻辑运算表达式时，逻辑表达式要加括号；
- 在实际开发中，逻辑运算的多重组合是重点，比如说需要同时满足多个条件，或者最少满足一个条件

# 十、逗号运算

把一行语句中的多个表达式连接起来，程序将从左到右执行表达式。

语法：表达式一,表达式二,……,表达式n;

逗号运算常用于声明多个变量。

```c++
int a,b;      // 声明变量a和b。
int a=10,b=20;  // 声明变量a和b并初始化。
```

也可以用于其它语句中，但是，逗号运算符是所有运算符中级别最低的，以下两个表达式的效果是不同的。

```c++
int a,b; 
b=a=2,a*2; 
b=(a=2,a*2);
```

但是不相关的表达式不建议使用逗号运算放一起

# 十一、运算优先级

一个表达式可以包含多个运算符，运算符的优先级决定了表达式各部分的执行顺序。

例如，按照运算规则， *的优先级比+高，所以的b * c将先执行：

`a + b * c;`

如果想让a + b先执行，则必须使用括号：

`(a + b) * c;`

如果一个表达式中操作符的优先级相同，那么它们的结合律（associativity）决定了它们的执行顺序（从左到右或从右到左）。例如，算术运算的组合方式是从左到右，赋值运算则是从右到左。如下：

| 表达式 | 结合律   | 组合方式 |
| ------ | -------- | -------- |
| a/b%c  | 从左到右 | (a/b)%c  |
| a=b=c  | 从右到左 | a=(b=c)  |

下表是全部运算符的优先级和结合律：

| 优先级 | 运算符           | 名称或含义                | 使用形式                  | 结合方向 |
| ------ | ---------------- | ------------------------- | ------------------------- | -------- |
| **1**  | []               | 下标                      | 地址[表达式]              | 左到右   |
| ()     | 圆括号           | （表达式）/函数名(形参表) |                           |          |
| .      | 成员选择（对象） | 对象.成员名               |                           |          |
| ->     | 成员选择（指针） | 对象指针->成员名          |                           |          |
| **2**  | -                | 负号运算符                | -表达式                   | 右到左   |
| (类型) | 强制类型转换     | (数据类型)表达式          |                           |          |
| ++     | 前置自增运算符   | ++变量名                  |                           |          |
| ++     | 后置自增运算符   | 变量名++                  |                           |          |
| --     | 前置自减运算符   | --变量名                  |                           |          |
| --     | 后置自减运算符   | 变量名--                  |                           |          |
| *      | 取值运算符       | *指针变量                 |                           |          |
| &      | 取地址运算符     | &变量名                   |                           |          |
| !      | 逻辑非运算符     | !表达式                   |                           |          |
| ~      | 按位取反运算符   | ~表达式                   |                           |          |
| sizeof | 长度运算符       | sizeof(表达式)            |                           |          |
| **3**  | /                | 除                        | 表达式/表达式             | 左到右   |
| *      | 乘               | 表达式*表达式             |                           |          |
| %      | 余数（取模）     | 整型表达式/整型表达式     |                           |          |
| **4**  | +                | 加                        | 表达式+表达式             | 左到右   |
| -      | 减               | 表达式-表达式             |                           |          |
| **5**  | <<               | 左移                      | 变量                      | 左到右   |
| >>     | 右移             | 变量>>表达式              |                           |          |
| **6**  | >                | 大于                      | 表达式>表达式             | 左到右   |
| >=     | 大于等于         | 表达式>=表达式            |                           |          |
| <      | 小于             | 表达式                    |                           |          |
| <=     | 小于等于         | 表达式                    |                           |          |
| **7**  | ==               | 等于                      | 表达式==表达式            | 左到右   |
| !=     | 不等于           | 表达式!= 表达式           |                           |          |
| **8**  | &                | 按位与                    | 表达式&表达式             | 左到右   |
| **9**  | ^                | 按位异或                  | 表达式^表达式             | 左到右   |
| **10** | \|               | 按位或                    | 表达式\|表达式            | 左到右   |
| **11** | &&               | 逻辑与                    | 表达式&&表达式            | 左到右   |
| **12** | \|\|             | 逻辑或                    | 表达式\|\|表达式          | 左到右   |
| **13** | ?:               | 条件运算符                | 表达式1? 表达式2: 表达式3 | 右到左   |
| **14** | =                | 赋值运算符                | 变量=表达式               | 右到左   |
| /=     | 除后赋值         | 变量/=表达式              |                           |          |
| *=     | 乘后赋值         | 变量*=表达式              |                           |          |
| %=     | 取模后赋值       | 变量%=表达式              |                           |          |
| +=     | 加后赋值         | 变量+=表达式              |                           |          |
| -=     | 减后赋值         | 变量-=表达式              |                           |          |
| <<=    | 左移后赋值       | 变量                      |                           |          |
| >>=    | 右移后赋值       | 变量>>=表达式             |                           |          |
| &=     | 按位与后赋值     | 变量&=表达式              |                           |          |
| ^=     | 按位异或后赋值   | 变量^=表达式              |                           |          |
| \|=    | 按位或后赋值     | 变量\|=表达式             |                           |          |
| **15** | ,                | 逗号运算符                | 表达式,表达式,…           | 左到右   |

注意：

- 如果不确定运算符的优先级，可以加括号；
- 多用括号，让代码的可读性更好。

# 十二、条件分支

程序结构有三种：顺序，条件，循环

语法：

```c++
if (表达式)

{

  // 表达式为真时执行的语句。

}

else

{

  // 表达式为假时执行的语句。

}
```

注意：

- if (表达式)之间的空格可以不写。
- 表达式必须使用括号。
- 表达式可以是具体的值。
- 表达式一般是关系运算和逻辑运算表达式，也可以是赋值运算或其它的表达式。
- 不要把if（变量名==值）写成if（变量名=值），否则就变成了赋值，而且逻辑会为真
- 整个if语句可以没有else分支。
- if或else分支花括号内的代码如果只有一行，花括号可以不写；如果一行也没有，花括号一定要写；如果有多行，花括号一定要写，如果不写，除了第一行，其它的代码将不是if语句的一部分。

if (表达式)和else后不能加分号，因为分号表示空语句。（C++用分号作为一条语句结束的标志。如果在C++程序中不小心多写了一个分号，那么该分号会被当成一条空语句。）

C++中，分号作为一个语句结束的标志，如果多写了，那么该分号会被当做一个空语句，实际上在一个语句后面写很多分号也没有影响

并且，if语句可以嵌套使用，实现多级（层）的条件判断（最多127层）。

语法：

```c++
if (表达式一)

{ 

  if (表达式二) 

  {

     // 表达式二为真时执行的语句。

  }

	else

	{

	  // 表达式二为假时执行的语句。

  }

}

else

{

  // 表达式一为假时执行的语句。

}
```

要注意，嵌套使用if语句时候，会出现if与else的配对问题。

C++编译器处理该问题的原则是：else总是与前面最近if 配对。

如果要改变这种配对关系，可以使用花括号来确定新的配对关系。

当然，考虑判断逻辑可能存在一些复杂情况，比如说有多重可能，可以使用多个条件进行if判断

语法：

```c++
if (表达式一)

{ 

  // 表达式一为真时执行的语句。

}

else if (表达式二)

{

  // 表达式二为真时执行的语句。

}

else if (表达式三)

{

  // 表达式三为真时执行的语句。

}

……

else if (表达式n)

{

  // 表达式n为真时执行的语句。

}

else

{

  // 全部表达式都不为真时执行的语句。

}
```

注意：

- 多条件的if语句本质上是嵌套的if语句。
- 最多只能有127个条件分支。

- 最后一个else可以没有。

当然，表达式的逻辑也可能相对复杂，就可以使用括号和逻辑表达式来进行复杂逻辑判断

三目运算也叫条件运算或三元运算，可以实现简单if语句的功能，但是书写更简洁。

语法： 表达式一 ? 表达式二 : 表达式三

先计算表达式一的值，如果为真，整个表达式的结果为表达式二的值，如果为假，整个表达式的结果为表达式三的值。

```c++
int a,b,c;
 a=7;
 b=6;
 c=(a>b)?a:b;
```

等同于

```c++
 if (a>b) c=a;
 else c=b;
```

三目运算表达式可以嵌套使用，但是，过于复杂的三目运算表达式不方便理解。

switch也是一种选择结构的语句，可以代替简单的多条件的if语句。

语法：

```c++


switch (表达式)

{

  case 值一: 

    语句一; 

    break;

  case 值二: 

    语句二; 

    break;

  ......

  case 值n: 

    语句n; 

    break;

  default: 

    上述条件都不满足时执行的语句; 

}
```

注意：

- case后面必须是整数和字符，或者是结果为整数和字符的表达式，但不能使用变量。
- default不是必须的，当没有default时，如果全部的case匹配失败，那么就什么都不执行。
- 每个分支不要漏写`break;`语句。

# 十三、循环结构

## while循环

```c++
while (表达式)

{

  语句块

}
```

先计算表达式的值，如果为真就执行语句块，执行完语句块后，回到循环首部再次计算表达式的值，如果为真又执行一次语句，这个过程会一直重复，直到表达式的值为假时不再执行语句块。

注意：

- 如果表达式的值永远为真，那么将进入死循环，所以在循环中应该有改变表达式的值的方法。
- 如果循环体中的语句块只有一行代码，大括号可以不书写。
- 有疑问先放一边，在以后的课程中，会介绍循环的各种使用方法。

## 循环的跳转

当然，也会碰到一些情况需要进行循环跳转，break和continue两个关键字用于控制循环体中代码的执行流程。

- break跳出（中止）当前循环语句。
- continue回到当前循环语句的首部，相当于跳过剩下的部分执行下一个循环

## for循环

另一种循环语句，作用等同while

语法：

```
for (语句一 ; 表达式 ; 语句二)

{

  语句块

}
```

1. 循环开始的时候，先执行语句一，在整个循环过程中语句一只会被执行一次。
2. 计算表达式的值，如果为真，就执行一次循环体中的语句块。
3. 执行完语句块后，执行一次语句二。
4. 重复第2步和第3，直到表达式的值不为真才结束for循环。

注意：

- 不要纠结for循环与while循环的区别，它们本质上没有区别。
- for循环一般需要一个相当于计数器的变量，在语句一中对它进行初始化，在语句二中进行计数操作。
- 在for循环的语句一中，可以声明计数器变量。
- 在for循环中，语句一、表达式和语句二都可以为空，for (;;)等同于while (true)。
- continue和break两个关键字也可以用在for循环体中。

## do-while语句

一个很少出现的循环结构

语法：

```c++
do
{
  语句块
} while (表达式);
```

功能与while语句类似，不同的是：

- 进入循环时，先执行一次语句块，再计算表达式的值。

- 循环的首部书写在循环的尾部，(表达式)后面还有一个分号。

## goto

goto语句也称为无条件转移语句。

goto的语法：goto 语句标号;

语句标号的语法：语句标号:

如果在程序中使用了goto，程序的流程将跳转到语句标号的位置，并执行它后面的代码。

其中语句标号是按[标识符](https://baike.baidu.com/item/标识符/7105638)规定书写的符号，放在某一语句行的前面，可以独占一行，标号后加[半角冒号](https://baike.baidu.com/item/半角冒号/1090543)。

语句标号用于标识语句的位置，与goto语句配合使用。

在实际开发中，goto语句容易造成程序流程的混乱，不方便理解，调试也更麻烦，不建议使用。

# 十四、函数基础

在复杂的程序中，如果全部的代码都写在main函数中，main函数体将非常庞大臃肿。

把任务分工到其它的函数中，main函数只负责程序的核心流程，具体的任务由其它函数完成。

这种思想就是模块化编程。

声明和定义函数的语法：

返回值的数据类型 函数名(参数一的数据类型 参数一, 参数二的数据类型 参数二,……)

{

  实现函数功能的代码。

  return 返回值;

}

比如说

```c++
int add(int a,int b)
{
    int c=a+b;
    return c;
}
```

函数的声明：让编译器知道函数的存在，包括返回值的数据类型、函数名和参数列表。

函数的定义：函数的实现过程。

注意：

- 函数的声明和定义可以书写在一起，也可以分开，如果书写在一起，一般放在main函数的上面，如果分开，一般在main函数的上面声明，在main函数的下面定义。

- 如果函数的声明和定义分开书写，函数的声明后面一定要有分号，函数的定义后面一定不能写分号。

- 在同一个程序中，函数只需要声明和定义一次，也可以多次声明，但只能定义一次。

- 函数的声明必须和函数的定义一致（返回值的数据类型、函数名和参数列表），如果函数名和参数列表不同，表示它们不是同一个函数。

- return语句返回值的数据类型必须与函数的声明一致。或者设置为无返回值类型

- 在函数体中，return语句可以多次使用。

- 如果函数的重点是实现功能，不关心返回值，返回值的数据类型填void，return语句后面就空着。甚至有返回值，也可以不使用

- 函数可以没有任何参数。

- 函数名是标识符，必须满足标识符的命名规则。

- 在函数的声明和函数的定义中，参数命名可以不同，但是没必要这么书写。

- 在main函数中不要调用main函数，否则会导致循环调用，堆栈溢出

- l 声明函数的代码必须放在调用之前，定义函数的代码可以放在调用之后。

  l 调用函数的时候，参数列表必须与函数的声明一致（参数的个数、书写的顺序和数据类型）。

  l 不管在什么地方，都不能调用main函数，但是，在普通函数中，可以调用其它的普通函数。

  l 调用函数的代码可以独占一条语句，也可以用于表达式（赋值运算、算术运算、关系运算、函数的参数）。

  l 如果函数用于表达式中，返回值的数据类型要匹配（否则可能会被隐式转换或编译错误）。

  l 如果函数有返回值，可以不关心它，忽略它。

## 变量作用域

作用域是指程序中变量存在（或生效）的区域，超过该区域变量就不能被访问。

变量分全局变量和局部变量两种，全局变量在整个程序中都可以访问，局部变量只能在函数或语句块的内部才能访问。

C++中定义变量的场景主要有五种：

1. 在全部函数外面定义的是全局变量。
2. 在头文件中定义的是全局变量。
3. 在函数和语句块内部定义的是局部变量。
4. 函数的参数是该函数的局部变量。
5. 函数内部用static修饰的是静态局部变量。

### 1 全局变量

在整个程序生命周期内都是有效的，在定义位置之后的任意函数中都能访问。

全局变量在主程序退出时由系统收回内存空间。

### 2局部变量

在函数或语句块内部的语句使用，在函数或语句块外部是不可用的。

局部变量在函数返回或语句块结束时由系统收回内存空间。

### 3 静态局部变量

用static修饰的局部变量生命周期和程序相同，并且只会被初始化一次。

其作用域为局部，当定义它的函数或语句块结束时，其作用域随之结束，相当于一个只有定义它的函数可用的全局变量

当程序想要使用全局变量的时候应该先考虑使用static（考虑到数据安全性）。

### 4 注意事项

- 全局变量和静态局部变量自动初始化为0。
- 局部变量不会自动初始化，其值是不确定的，程序中应该有初始化局部变量的代码，否则编译可能会报错（不同的编译器不一样）。
- 局部变量和全局变量的名称可以相同，在某函数或语句块内部，如果局部变量名与全局变量名相同，就会屏蔽全局变量而使用局部变量，如果想使用全局变量，可以在变量名前加两个冒号（::）。
- for循环初始化语句中定义的变量的作用域是for语句块。

## 参数传递

调用函数的时候，调用者把数值（实参）赋给了函数的参数（形参。就好比说文件传递，我把我的文件复印了一份给你，你做的任何修改都不会影响我的文件，

实参：调用者程序中书写的在函数名括号中的参数，可以是常量、变量和表达式。

形参：函数的参数列表。

在函数定义的代码中，修改形参的值，会不会影响实参。

## 分文件编写

如果代码量很大，我们就需要分文件编写，进行模块化设计与实现，提高编程效率

头文件（.h）：需要包含的头文件，声明全局变量，函数的声明，数据结构和类的声明等。

源文件（.cpp）：函数的定义、类的定义。

主程序：main函数，程序的核心流程，需要用#include "头文件名"把头文件包含进来。

如果是包含系统的头文件，就使用尖括号，如果包含自己写的头文件，就使用双引号

编译：

Windows是集成开发环境，不需要写编译指令。

在Linux系统下，把全部的源文件一起编译，如：g++ -o demo demo.cpp tools.cpp girls.cpp

## 递归函数调用

也可以在函数中调用自身，但是记得设置终止条件

# 十五、数据类型

## sizeof

sizeof运算符用于求数据类型或变量占用的内存空间。

用于数据类型：sizeof(数据类型)

用于变量：sizeof(变量名) 或 sizeof 变量名

注意：

l 在32位和64位操作系统中，同一种数据类型占用的内存空间可能不一样。

l 字符串（string）不是C++的基本数据类型，用sizeof求它占用内存的大小没有意义。

## 整型

C++用int关键字来声明整型变量（int 是 integer 的简写）。

在声明整型变量的时候，可以在int关键字之前加signed、unsigned、short和long四种修饰符。

signed：有符号的，可以表示正数和负数。

unsigned：无符号的，只能表示正数，例如超女的身高和体重等。

short：短的，取值范围小，占用内存少。

long：长的，取值范围大，占用内存多。

注意：

l 整数的取值范围与计算机操作系统和C++语言编译器有关，没有一个固定的数值，我们可以根据它占用的内存大小来推断它的取值范围。

一个位的取值是 0 1 1=$2^1-1$

两个位的取值是 00 01 10 11 3=$2^2-1$

三个位的取值是 000 001 …… 111 7=$2^3-1$

- 一个字节有8个位，表示的数据的取值范围是$2^8-1$，即255。
- 如果占用的内存是两个字节，无符号型取值范围是$2^8\times 2^8-1$。
- 如果占用的内存是四个字节，无符号型取值范围是$2^8 \times 2^8 \times 2^8 \times 2^8-1$。
- 如果占用的内存是八个字节，无符号型取值范围是$2^8 \times 2^8 \times 2^8 \times 2^8 \times 2^8 \times 2^8 \times 2^8 \times 2^8 \times$。
- 如果是有符号，取值范围减半，因为符号占一个位。
- 计算机用最高位1位来表达符号（0-正数，1-负数），unsigned修饰过的正整数不需要符号位，在表达正整数的时候比signed修饰的正整数取值大一倍。
- 给整型变量赋值不能超出它的取值范围，否则能产生不可预后的后果。
- 在实际开发中，为了防止超出取值范围，应该保证有足够的空间。

## 整数进制

整数默认是十进制，一个表示十进制的数字不需要任何特殊的格式。

### 1、二进制

二进制由 0 和 1 两个数字组成，书写时必须以0b或0B（不区分大小写）开头。

```c++
  int a = 0b101;      // 换算成十进制为 5
  int b = -0b110010;  // 换算成十进制为 -50
  int c = 0B100001;   // 换算成十进制为 33
```

注意，C++标准并不支持上面的二进制写法，只是有些编译器自己进行了扩展，才支持二进制数字。换句话说，并不是所有的编译器都支持二进制数字，只有一部分编译器支持，并且跟编译器的版本有关系。

### 2、八进制

八进制由 0~7 八个数字组成，书写时必须以0开头（注意是数字 0，不是字母 o）。

以下是合法的八进制数：

```c++
  int a = 015;      // 换算成十进制为 13
  int b = -0101;    // 换算成十进制为 -65
  int c = 0177777;  // 换算成十进制为 65535
```

### 3、十六进制

十六进制由数字 0~9、字母 A~F 或 a~f（不区分大小写）组成，书写时必须以0x或0X（不区分大小写）开头。

以下是合法的十六进制：

```c++
 int a = 0X2A;  // 换算成十进制为 42
 int b = -0XA0;  // 换算成十进制为 -160
 int c = 0xffff;  // 换算成十进制为 65535
```

### 4、需要注意的坑

在C++中，不要在十进制数前面加0，会被编译器当成八进制。

还有，不要随便删掉别人程序中整数前面的0，它不是多余的。

## 浮点数

C++浮点型分三种：float（单精度）、double（双精度）、long double（扩展精度）。

三者的区别是表示有效数字的范围不同。

|  数据类型   |   占用空间   |      有效数字范围      |
| :---------: | :----------: | :--------------------: |
|    float    |    4字节     |  7位有效数字     8位   |
|   double    |    8字节     | 15～16位有效数字  17位 |
| long double | 不少于double | 不低于double     17位  |

注意：

- 在VS和Linux中，long double占用的内存空间分别是8和16字节。
- 有效数字包括了小数点前面和后面的数字。
- 书写小数默认为双精度类型，可以在数字后面加字母f说明这是单精度类型的
- C++缺省显示6位有效数字，如果要显示更多的有效数字，可以用printf()函数。
- 浮点数的存储方法和整数不一样，比较复杂，如无必要，不用研究。（百度“为什么浮点数的小数位很多”、“为什么浮点数不精确”）
- 在实际开发中，用整数代替浮点数，整数的运算更快，精度更高，比如说175厘米代替1.75米

## 字符型

字符型（char）占用的内存空间是1个字节，书写用单引号包含。

在内存中，不存放字符本身，而是存放与它对应的编码，即ASCII码。

ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是现今最通用的单字节编码方案，包含了33个控制字符（具有特殊含义无法显示的字符）和95个可显示字符。

实际上在C++中，字符型是可以做一些运算的，比如说

```c++
char a='a';
a=a+1;
```

这样实际上变量存储的就是`a`字符对应的编码然后加一，也就是字符`b`，在这时候打印就会得到字符`b`

- `A`的编码是65
- `a`的编码是97
- 字符的本质是整数，取值范围是0～127。
- 在书写的时候可以用单引号包含，也可以用整数。
- 如果书写的时候用单引号包含，程序执行的时候，将把符号解释为对应的整数。
- 显示的时候，把整数解释为对应的符号，也可以直接显示整数。具体看数据类型
- 可以与整数进行任何运算，运算的时候，书写方式可以用字符，也可以用整数。
- C++为什么没有提供1字节的整型？
- 字符型也可以用unsigned修饰，意义何在？

## 转义字符

在C++程序中，使用转义字符的原因有两个：

- 控制字符没有符号，无法书写，只能用其它的符号代替。
- 某些符号已被C++征用，语义冲突，只能用其它的符号代替。比如说斜线`\`就需要使用两个斜线表示

常用的有换行符和制表符

## C++11原始字面量

原始字面量（值）可以直接表示字符串的实际含义，不需要转义和连接。比如说文件路径

语法：R"(字符串的内容)"

R"xxx(字符串的内容)xxx"

比如说

```c++
string s=R"hello(C:\user\Document)hello"
```

使用R表示字面量，然后将需要字面量的部分使用括号括起来，没有被括起来的地方就是注释性质，不会被输出，这样子可以提高代码可读性，没有被括起来的部分称为标签，不是字符串内容的一部分，并且必须成对出现

如果字符串很长就需要换行书写，每一行最后需要带斜线`\`作为连接符

但是这种如果直接打印输出的话会有空格，所以需要使用字面量（不带斜线）会有更好的可读性（打印输出也是换行表示）

## 字符串型

C++风格字符串：string 变量名="字符串的内容" ;

C风格字符串：char 变量名[]="字符串的内容" ;

C风格字符串的本质是字符数组，C++风格字符串的本质是类，它封装了C风格字符串。

C++风格字符串的常用操作：

- 赋值：变量名="字符串的内容" ;
- 拼接：变量名=变量名+"字符串的内容一"+"字符串的内容一"+......+"字符串的内容n" ;
- 如果字符串的内容都是常量，不要写加号（+），如果内容很长，可以分成多行书写。
- 比较：支持==、!=、>和<关系运算符，常用的是==和!=。

## bool型

在C和C++中，关系运算和逻辑运算的结果有两种：真和假。

C语言用0表示假，非0表示真。

为了提高代码的可读性，C++新增了 bool 类型，占用1字节的内存，用true表示真，false表示假。

bool类型本质上是1字节的整数（unsigned char），取值只有1和0。

在程序中，书写的时候可以用true和false，编译器把它们解释为1和0。

如果对bool型变量赋非0的值，将转换成1。

用cin输入和cout输出的时候，仍是1和0，不会被解释为true和false。

## 数据类型转换

计算机进行运算时，要求各操作数的类型具有相同的大小和存储方式。

在实际开发中，不同类型的数据进行混合运算是基本需求。

自动类型转换：某些类型的转换编译器可以隐式的进行，不需程序员干预。

强制类型转换：有些类型的转换需要程序员显式指定。

### 1 自动类型转换

不同数据类型的差别在于取值范围和精度，数据的取值范围越大，精度越高。

整型从低到高：

char -> short -> int -> long -> long long

浮点型从低到高：

float -> double -> long double

自动类型转换的规则如下：

- 如果一个表达式中出现了不同类型操作数的混合运算，较低类型将自动向较高类型转换。这种转换没有风险
- 当表达式中含有浮点型操作数时，所有操作数都将转换为浮点型。
- 赋值运算的右值类型与左值类型不一致时，将右值类型提升/降低为左值类型。
- 赋值运算右值超出了左值类型的表示范围，把该右值截断后赋给左值，所得结果可能毫无意义。

### 2 强制类型转换

为了让程序设计更灵活，转换的目的更清晰，C++提供了强制类型转换的方法，也称之为显式转换。

强制类型转换的语法：(目标类型)表达式 或 目标类型(表达式)

注意：

- 如果使用强制转换，表示程序员已有明确的目的。
- 如果转换的行为不符合理，后果由程序员承担。
- 如果采用了强制类型转换，编译的告警信息将不再出现。
- 类型转换运算符的优先级比较高，如果没把握就加括号。

## 数据类型的别名

创建数据类型的别名有两个目的：

- 为名称复杂的类型创建别名，方便书写和记忆。
- 创建与平台无关的数据类型，提高程序的兼容性。

语法：typedef 原数据类型名 别名;

C++11还可以用using关键字创建数据类型的别名。

语法：using 别名=原数据类型名;

# 十六、指针和内存

## 1.变量的地址

指针的存在，是决定了C++的效率远高于解释型语言的原因之一

C++用运算符&获取变量在内存中的起始地址，地址一般使用十六进制存储

同时注意一下，cout有bug，显示地址的时候可能会将其当成字符串显示，所以有两种解决方法

```c++
cout<<(void*)&a<<endl;
cout<<(int)&a<<endl;
```

第一种可以让地址以十六进制显示，第二个是将地址转换为十进制整数，方便理解和计算

## 2.指针变量

指针变量简称指针，它是一种特殊的变量，专用于存放变量在内存中的起始地址。

语法：数据类型 *变量名;

数据类型和星号，星号和变量名之间的空格都是可有可无的。

数据类型必须是合法的C++数据类型（int、char、double或其它自定义的数据类型）。

星号*与乘法中使用的星号是相同的，但是，在这个场景中，星号用于表示这个变量是指针。

地址是一样的十六进制数，但是指针是有类型的，所以声明指针的时候需要指定数据类型

## 3.对指针赋值

不管是整型、浮点型、字符型，还是其它的数据类型的变量，它的地址都是一个十六进制数。我们用整型指针存放整数型变量的地址；用字符型指针存放字符型变量的地址；用浮点型指针存放浮点型变量的地址，用自定义数据类型指针存放自定义数据类型变量的地址。

语法：指针=&变量名;

注意

- 对指针的赋值操作也通俗的被称为“指向某变量”，被指向的变量的数据类型称为“基类型”。
- 如果指针的数据类型与基类型不符，编译会出现警告。但是，可以强制转换它们的类型。

指针也是变量，是变量就要占用内存空间。

在64位的操作系统中，不管是什么类型的指针，占用的内存都是8字节。

在C++中，指针是复合数据类型，复合数据类型是指基于其它类型而定义的数据类型，在程序中，int是整型类型，int*是整型指针类型，int*可以用于声明变量，可以用于sizeof运算符，可以用于数据类型的强制转换，总的来说，把int*当成一种数据类型就是了。

## 4.使用指针

声明指针变量后，在没有赋值之前，里面是乱七八糟的值，这时候不能使用指针。

指针存放变量的地址，因此，指针名表示的是地址（就像变量名可以表示变量的值一样）

运算符被称为间接值或解除引用（解引用）运算符，将它用于指针，可以得到该地址的内存中存储的值，*也是乘法符号，C++根据上下文来确定所指的是乘法还是解引用。

变量和指向变量的指针就像同一枚硬币的两面，可以通过指针解引用去读取和修改变量的值，变量的值改变之后，通过指针指向的内容也会改变

对于存储在计算机内存中的变量，起始地址决定位置，数据类型决定了占用内存的大小和操作数据的方式

## 5.指针传参

如果把函数的形参声明为指针，调用的时候把实参的地址传进去，形参中存放的是实参的地址，在函数中通过解引用的方法直接操作内存中的数据，可以修改实数的值，这种方法被通俗的称为地址传递或传地址。

值传递：函数的形参是普通变量。

传地址的意义如下：

- 可以在函数中修改实参的值。
- 减少内存拷贝，提升性能。

## 6.const修饰指针

### 常量指针

语法：const 数据类型 *变量名;

不能通过解引用的方法修改内存地址中的值（用原始的变量名是可以修改的）。或者说这是指向常量的指针，指针可以改动，但是指向的内容不可改

注意：

- 指向的变量（对象）可以改变（之前是指向变量a的，后来可以改为指向变量b）。
- 一般用于修饰函数的形参，表示不希望在函数里修改内存地址中的值。
- 如果用于形参，虽然指向的对象可以改变，但这么做没有任何意义。
- 如果形参的值不需要改变，建议加上const修饰，程序可读性更好。

### 指针常量

语法：数据类型 * const 变量名;

指向的变量（对象）不可改变，或者说指针本身不能改动，但是指针指向的内存可以改动

注意：

l 在定义的同时必须初始化，否则没有意义。

l 可以通过解引用的方法修改内存地址中的值。

l C++编译器把指针常量做了一些特别的处理，改头换面之后，有一个新的名字，叫引用。

### 常指针常量

语法：const 数据类型 * const 变量名;

指向的变量（对象）不可改变，不能通过解引用的方法修改内存地址中的值。

常引用。

常量指针：指针指向可以改，指针指向的值不可以更改。

指针常量：指针指向不可以改，指针指向的值可以更改。

常指针常量：指针指向不可以改，指针指向的值不可以更改。

记忆秘诀：表示指针，指针在前先读指针；指针在前指针就不允许改变。

常量指针：const 数据类型 *变量名

指针常量：数据类型 * const 变量名

## 7.void关键字

在C++中，void表示为无类型，主要有三个用途：

1）函数的返回值用void，表示函数没有返回值。

```c++
void func(int a,int b)
{
  // 函数体代码。
  return;
}
```

2）函数的参数填void，表示函数不需要参数（或者让参数列表空着）。

```c++
int func(void)
{
  // 函数体代码。
  return 0;
}
```

3）函数的形参用void ，表示接受任意数据类型的指针。

注意：

- 不能用void声明变量，它不能代表一个真实的变量，但是，用void *可以。
- 不能对void 指针直接解引用（需要转换成其它类型的指针）。
- 把其它类型的指针赋值给void*指针不需要转换。
- 把void *指针赋值给把其它类型的指针需要转换。

## 8.堆区内存动态分配

使用堆区的内存有四个步骤：

1. 声明一个指针；
2. 用new运算符向系统申请一块内存，让指针指向这块内存；
3. 通过对指针解引用的方法，像使用变量一样使用这块内存；
4. 如果这块内存不用了，用delete运算符释放它。

申请内存的语法：new 数据类型(初始值);  // C++11支持{}

当然也可以申请一系列的内存，比如说new 数据类型[num]，其中num是数量，这样可以一次申请这么多的数据类型的空间

如果申请成功，返回一个地址；如果申请失败，返回一个空地址（暂时不考虑失败的情况）。

释放内存的语法：delete 地址;

释放内存不会失败（还钱不会失败）。

注意：

- 动态分配出来的内存没有变量名，只能通过指向它的指针来操作内存中的数据。
- 如果动态分配的内存不用了，必须用delete释放它，否则有可能用尽系统的内存。
- 动态分配的内存生命周期与程序相同，程序退出时，如果没有释放，系统将自动回收。
- 就算指针的作用域已失效，所指向的内存也不会释放。
- 用指针跟踪已分配的内存时，不能跟丢。

## 9.二级指针

指针是指针变量的简称，也是变量，是变量就有地址。

指针用于存放普通变量的地址。

二级指针用于存放指针变量的地址。

声明二级指针的语法：数据类型** 指针名;

使用指针有两个目的：1）传递地址；2）存放动态分配的内存的地址。

在函数中，如果传递普通变量的地址，形参用指针；传递指针的地址，形参用二级指针。

把普通变量的地址传入函数后可以在函数中修改变量的值；把指针的地址传入函数后可以在函数中修改指针的值。

使用的时候，二级指针每前置一个星号，就是一次解引用，第一次解引用得到一级指针的内容，也就是一级指针指向内容的地址，二次解引用得到一级指针指向的内容

## 10.空指针

在C和C++中，用0或NULL都可以表示空指针。

声明指针后，在赋值之前，让它指向空，表示没有指向任何地址。

### 使用空指针的后果

如果对空指针解引用，程序会崩溃。

如果对空指针使用delete运算符，系统将忽略该操作，不会出现异常。所以，内存被释放后，也应该把指针指向空。

在函数中，应该有判断形参是否为空指针的代码，目的是保证程序的健壮性。

为什么空指针访问会出现异常？

NULL指针分配的分区：其范围是从 0x00000000到0x0000FFFF。这段空间是空闲的，对于空闲的空间而言，没有相应的物理存储器与之相对应，所以对这段空间来说，任何读写操作都是会引起异常的。空指针是程序无论在何时都没有物理存储器与之对应的地址。为了保障“无论何时”这个条件，需要人为划分一个空指针的区域，固有上面NULL指针分区。

可以使用指针==0或者NULL的方式判断这是否是空指针

### C+11的nullptr

用0和NULL表示空指针会产生歧义，C++11建议用nullptr表示空指针，也就是(void *)0。

NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议用nullptr替代NULL吧，而NULL就当做0使用。

注意：在Linux平台下，如果使用nullptr，编译需要加-std=c++11参数。

## 11.野指针

野指针就是指针指向的不是一个有效（合法）的地址。

在程序中，如果访问野指针，可能会造成程序的崩溃。

出现野指针的情况主要有三种：

1）指针在定义的时候，如果没有进行初始化，它的值是不确定的（乱指一气）。编译器不会帮我们发现这个问题

2）如果用指针指向了动态分配的内存，内存被释放后，指针不会置空，但是，指向的地址已失效。

3）指针指向的变量已超越变量的作用域（变量的内存空间已被系统回收），让指针指向了函数的局部变量，或者把函数的局部变量的地址作为返回值赋给了指针。

规避方法：

1）指针在定义的时候，如果没地方指，就初始化为nullptr。

2）动态分配的内存被释放后，将其置为nullptr。

3）函数不要返回局部变量的地址。

注意：野指针的危害比空指针要大很多，在程序中，如果访问野指针，可能会造成程序的崩溃。是可能，不是一定，程序的表现是不稳定，增加了调试程序的难度。

容易碰到的一种野指针就是数组越界，数组越界的本质就是野指针，不管采用数组表示法还是指针表示法，但是可以选择使用C++标准库封装好的数组，就不会出现越界的情况了

## 12.函数指针

与指针函数不同，**函数指针** 的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针

函数的二进制代码存放在内存四区中的代码段，函数的地址是它在内存中的起始地址或者说入口地址。

如果把函数的地址作为参数传递给函数，就可以在函数中灵活的调用其它函数。这种调用的方法称为函数的回调

使用函数指针的三个步骤：

a）声明函数指针；

b）让函数指针指向函数的地址；

c）通过函数指针调用函数。

### 声明函数指针

声明普通指针时，必须提供指针的类型。同样，声明函数指针时，也必须提供函数类型，函数的类型是指返回值和参数列表（函数名和形参名不是）

假设函数的原型是：

int func1(int bh,string str);

int func2(int no,string message);

int func3(int id,string info);

bool func4(int id,string info);

bool func5(int id);

则函数指针的声明是：

int  (*pfa)(int,string);

bool (*pfb)(int,string);

bool (*pfc)(int);

pfa、pfb、pfc是函数指针名，必须用括号，否则就成了返回指针的函数。

这里注意一下，是先有某个函数，我们再去声明指向此函数的指针变量，函数指针的形参可以与原函数一致，也可以只写数据类型

### 函数指针的赋值

函数名就是函数的地址。

函数指针的赋值：函数指针名=函数名;

### 函数指针的调用

(*函数指针名)(实参);//C语言

函数指针名(实参);//C++语言

```c++
void (*pfun)(int);//声明函数指针
pfun=func;//对函数指针赋值，func是一个自定义函数
pfun(1001);//C++语言
(*pfun)(1001);//C语言
```

### 回调函数

函数指针的一个非常典型的应用就是**回调函数**。
什么是回调函数？
回调函数就是一个通过指针函数调用的函数。其将函数指针作为一个参数，传递给另一个函数。
回调函数并不是由实现方直接调用，而是在特定的事件或条件发生时由另外一方来调用的。

使用回调函数，我们不需要提前知道想调用的函数具体的函数名，只需要传入函数指针就可以进行调用，更为便利

示例代码如下

```c++
int callback(int n, int (*p)(int))
{
        return p(n);
}
```

# 十七、数组

数组是一组数据类型相同的变量，可以存放一组数据。

## 1.一维数组

### 1）创建数组

声明数组的语法：数据类型 数组名[数组长度];

注意：数组长度必须是整数，可以是常量，也可以是变量和表达式。

C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量。

### 2）数组的使用

可以通过下标访问数组中元素，数组下标从0开始。

数组中每个元素的特征和使用方法与单个变量完全相同。

语法：数组名[数组下标]

注意：

- 数组下标也必须是整数，可以是常量，也可以是变量。
- 合法的数组下标取值是：0~(数组长度-1)。

### 3）数组占用内存的情况

数组在内存中占用的空间是连续的。

用sizeof(数组名)可以得到整个数组占用内存空间的大小（只适用于C++基本数据类型）。

### 4）数组的初始化

声明的时候初始化：

数据类型 数组名[数组长度] = { 值1，值2，值3, ...... , 值n};

数据类型 数组名[ ] = { 值1，值2，值3, ...... , 值n};

数据类型 数组名[数组长度] = { 0 };  // 把全部的元素初始化为0。

数据类型 数组名[数组长度] = { };   // 把全部的元素初始化为0。

注意：如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。如果想把数组中全部的元素初始化为0，可以在{}内只填一个0或什么也不填。

​	C++11标准可以不写等于号。

### 5）清空数组

用memset()函数可以把数组中全部的元素清零。（只适用于C++基本数据类型）

函数原型：void *memset(void *s, int c, size_t n);

注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>

### 6）复制数组

用memcpy()函数可以把数组中全部的元素复制到另一个相同大小的数组。（只适用于C++基本数据类型）

函数原型：void *memcpy(void *dest, const void *src, size_t n);

注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>

## 2.一维数组和指针

### 1）指针的算术

将一个整型变量加1后，其值将增加1。

但是，将指针变量（地址的值）加1后，增加的量等于它指向的数据类型的字节数。

```c++
char a;
cout<<(void *)&a<<endl;
cout<<(void *)(&a+1)<<endl;
```

当地址加一之后，两次地址的差等于char类型的大小，或者说，指针加一之后，增加的量就是数据类型所占的字节数，加其他整数也类似

### 2）数组的地址

```c++
double a[5];
cout<<(long long)&a[0]<<endl;
int* p=a;
cout<<(long long)(p+1)<<endl;
```

也可以通过指针p的算数运算访问数组各个元素的地址和内容

a）数组在内存中占用的空间是连续的。

b）C++将数组名解释为数组第0个元素的地址。

c）数组第0个元素的地址和数组首地址的取值是相同的。

d）数组第n个元素的地址是：数组首地址+n

e）C++编译器把  数组名[下标] 解释为(数组首地址+下标)

### 3）数组的本质

数组是占用连续空间的一块内存，数组名被解释为数组第0个元素的地址。C++操作这块内存有两种方法：数组解释法和指针表示法，在操作内存方面，它们是等价的。区别在于，数组名不可更改

### 4）数组名不一定会被解释为地址

在多数情况下，C++将数组名解释为数组的第0个元素的地址，但是，将sizeof运算符用于数据名时，将返回整个数组占用内存空间的字节数。

但是注意一下，可以修改指针的值，但数组名是常量，不可修改。

### 5）越界问题

但是注意一下，数组不要越界，虽然通过指针操作的越界不一定会直接引起报错，但是可能引发无法预知的后果，比如说数据错乱等

或者说，数组越界的本质就是野指针

可以使用C++封装的标准数组，就不会出现越界的情况

## 3.一维数组用于函数的参数

### 1）指针的数组表示

在C++内部，用指针来处理数组。

C++编译器把  数组名[下标] 解释为(数组首地址+下标)

C++编译器把  地址[下标] 解释为(地址+下标)

就比如说，声明某个数据类型的数组arr，然后将其首地址传给指针p

```c++
double a[5];
cout<<(long long)&a[0]<<endl;
int* p=a;
cout<<(long long)(p+1)<<endl;
```

在不越界的情况下，实际上对首地址进行加法，就是得到相应往后第几个元素的地址，因为数组名实际上就是首元素的地址，而且具体地址的差就是数据类型的大小

### 2）一维数组用于函数的参数

一维数组用于函数的参数时，只能传数组的地址，并且必须把数组长度也传进去，除非数组中有最后一个元素的标志。因为我们无法直接获取数组的长度信息

书写方法有两种：

``` c++
void func(int* arr, int len);
void func(int arr[], int len);
```

注意：

在函数中，可以用数组表示法，也可以用指针表示法。

在函数中，不要对指针名用sizeof运算符，它不是数组名，形参传入的是指针而不是数组，其siezof运算的结果永远是8

## 4.使用new创建一维数组

普通数组在栈上分配内存，栈很小；如果需要存放更多的元素，必须在堆上分配内存。

动态创建一维数组的语法：数据类型 *指针=new 数据类型[数组长度];

释放一维数组的语法：delete [] 指针;

注意：

- 动态创建的数组没有数组名，不能用sizeof运算符。
- 可以用数组表示法和指针表示法两种方式使用动态创建的数组。
- 必须使用delete[]来释放动态数组的内存（不能只用delete）。
- 不要用delete[]来释放不是new[]分配的内存。
- 不要用delete[]释放同一个内存块两次（否则等同于操作野指针）。
- 对空指针用delete[]是安全的（释放内存后，应该把指针置空nullptr）。
- 声明普通数组的时候，数组长度可以用变量，相当于在栈上动态创建数组，并且不需要释放。
- 如果内存不足，调用new会产生异常，导致程序中止；如果在new关键字后面加(std::nothrow)选项，则返回nullptr，不会产生异常。
- 为什么用delete[]释放数组的时候，不需要指定数组的大小？因为系统会自动跟踪已分配数组的内存。

## 5.qsort

qsort()函数用于对各种数据类型的数组进行排序。

函数的原型：

```c++
	void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
```

第一个参数：数组的起始地址。

第二个参数：数组元素的个数（数组长度）。

第三个参数：数组元素的大小（sizeof(数组的数据类型)）。

第四个参数：回调函数的地址。

回调函数决定了排序的顺序，声明如下：

```c++
int compar(const void *p1, const void *p2);
```

1）如果函数的返回值< 0 ，那么p1所指向元素会被排在p2所指向元素的前面。

2）如果函数的返回值==0，那么p1所指向元素与p2所指向元素的顺序不确定。

3）如果函数的返回值> 0 ，那么p1所指向元素会被排在p2所指向元素的后面。

​	

​	void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));

qsort()函数的其它细节：

l 形参中的地址用void是为了支持任意数据类型，在回调函数中必须具体化。

l 为什么需要第三个形参size_t size？

l size_t是C标准库中定义的，在64位系统中是8字节无符号整型（unsigned long long）。

typedef unsigned long long size_t

排序的需求除了升序和降序，还有很多不可预知的情况，只能用回调函数。

## 6.C风格字符串

在C++中，string类使用方便，可以自动扩展，不需要担心内存的问题，但是我们仍然需要学习C风格字符串

- string是C++的类，封装了C风格字符串
- 在某些场合中，C风格字符串更方便高效
- 某些开源库和数据库的接口函数只有C版本而没有C++版本，比如说MySQL，并且Linux提供的函数库都是C语言

C语言约定：如果字符型（char）数组的末尾包含了空字符\0（也就是0），那么该数组中的内容就是一个字符串。

```c++
string str="abcd";
cout<<str[0]<<endl<<str[1]<<endl<<str[2]<<endl<<str[3]<<endl;
```

这样是不会出现越界问题的，因为`str[3]`中是空字符，打印是没有显示的，但是我们可以将其转换为ASCII码

```c++
string str="abcd";
cout<<(int)str[0]<<endl<<(int)str[1]<<endl<<(int)str[2]<<endl<<(int)str[3]<<endl;
```

就可以看到第四个元素的ASCII实际上是0

### 1）初始化方法

```c++
***\*char name[11];         //可以存放10个字符，没有初始化，里面是垃圾值。
char name[11] = "hello";     // 手动确定长度，初始内容为hello，后面的位置系统会自动添加0。
char name[]  = { "hello" };    // 初始内容为hello，系统会自动添加0，数组长度是6。
char name[11] = { "hello" };    // 初始内容为hello，系统会自动添加0。
char name[11]  { "hello" };    // 初始内容为hello，系统会自动添加0。C++11标准。
***\*char name[11] = { 0 };      //把全部的元素初始化为
```

### 2）清空字符串

```c++
memset(name,0,sizeof(name));  // 把全部的元素置为0。
name[0]=0;    // 只能清空一个位置，无非清空整个字符串，不规范，有隐患，不推荐。
```



### 3）字符串复制或赋值strcpy()

```c++
char *strcpy(char* dest, const char* src);
```

功 能: 将参数src字符串拷贝至参数dest所指的地址。

返回值: 返回参数dest的字符串起始地址。

复制完字符串后，会在dest后追加一个0。

如果参数dest所指的内存空间不够大，会导致数组的越界。

示例如下

```c++
char name[11];
strcpy(name,"hello");
```

这样子就会将数组的前五位赋值，后面加一个0，再后面的就不会有改动，也就是0-4下标的是字幕，下标5的位置为0，后面的没有变动

### 4）字符串复制或赋值strncpy()

```c++
char * strncpy(char* dest,const char* src, const size_t n);
```

功能：把src前n个字符的内容复制到dest中。

返回值：dest字符串起始地址。

如果src字符串长度小于n，则拷贝完字符串后，在dest后追加0，直到n个。

如果src的长度大于等于n，就截取src的前n个字符，不会在dest后追加0。

如果参数dest所指的内存空间不够大，会导致数组的越界。

### 5）获取字符串的长度strlen()

```c++
 size_t  strlen( const char*  str);
```

功能：计算字符串的有效长度，不包含0。

返回值：返回字符串的字符数。

strlen()函数计算的是字符串的实际长度，遇到0结束。

### 6）字符串拼接strcat(）

```c++
char *strcat(char* dest,const char* src);
```

功能：将src字符串拼接到dest所指的字符串尾部。

返回值：返回dest字符串起始地址。

dest最后原有的结尾字符0会被覆盖掉，并在连接后的字符串的尾部再增加一个0。

如果参数dest所指的内存空间不够大，会导致数组的越界。

### 7）字符串拼接strncat()

```c++
char *strncat (char* dest,const char* src, const size_t n);
```

功能：将src字符串的前n个字符拼接到dest所指的字符串尾部。

返回值：返回dest字符串的起始地址。

如果n大于等于字符串src的长度，那么将src全部追加到dest的尾部，如果n小于字符串src的长度，只追加src的前n个字符。

strncat会将dest字符串最后的0覆盖掉，字符追加完成后，再追加0。

如果参数dest所指的内存空间不够大，会导致数组的越界。

### 8）字符串比较strcmp()和strncmp()

int strcmp(const char *str1, const char *str2 );

功能：比较str1和str2的大小。

返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；

int strncmp(const char *str1,const char *str2 ,const size_t n);

功能：比较str1和str2前n个字符的大小。

返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；

两个字符串比较的方法是比较字符的ASCII码的大小，从两个字符串的第一个字符开始，如果分不出大小，就比较第二个字符，如果全部的字符都分不出大小，就返回0，表示两个字符串相等。

在实际开发中，程序员一般只关心字符串是否相等，不关心哪个字符串更大或更小。

### 9）查找字符strchr()和strrchr()

```c++
const char *strchr(const char *s, int c);
```

返回在字符串s中第一次出现c的位置，如果找不到，返回0。

```c++
const char *strrchr(const char *s, int c);
```

返回在字符串s中最后一次出现c的位置，如果找不到，返回0。

### 10）查找字符串strstr()

```c++
char *strstr(const char* str,const char* substr);
```

功能：检索子串在字符串中首次出现的位置。

返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回0。

### 11）用于string的表达式

可以把C风格的字符串用于包含了string类型的赋值拼接等表达式中。

### 12）注意事项

a）字符串的结尾标志是0，按照约定，在处理字符串的时候，会从起始位置开始搜索0，一直找下去，找到为止（不会判断数组是否越界）。

b）结尾标志0后面的都是垃圾内容。

c）字符串在每次使用前都要初始化，减少入坑的可能，是每次，不是第一次。

d）不要在子函数中对字符指针用sizeof运算，所以，不能在子函数中对传入的字符串进行初始化，除非字符串的长度也作为参数传入到了子函数中。

e）在VS中，如果要使用C标准的字符串操作函数，要在源代码文件的最上面加

`#define _CRT_SECURE_NO_WARNINGS`

## 7.二维数组

一维数组的数学概念是线性表，二维数组的数学概念是矩阵。

### 1）创建二维数组

声明二维数组的语法：数据类型 数组名[行数]\[列数\];

注意：数组长度必须是整数，可以是常量，也可以是变量和表达式。

C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量。

### 2）二维数组的使用

可以通过行下标和列下标访问二维数组中元素，下标从0开始。

二维数组中每个元素的特征和使用方法与单个变量完全相同。

语法：数组名[行下标]\[列下标\]

注意：

l 二维数组下标也必须是整数，可以是常量，也可以是变量。

l 合法的行下标取值是：0~(行数-1)。

l 合法的列下标取值是：0~(列数-1)。

### 3）二维数组占用内存的情况

用sizeof(数组名)可以得到整个二维数组占用内存空间的大小（只适用于C++基本数据类型）。

二维数组在内存中占用的空间是连续的，或者可以理解为，二维数组本质上是一维数组，但是其元素又是同样大小和类型的一维数组，对于更高维度的数组也类似

### 4）二维数组的初始化

声明的时候初始化：

数据类型 数组名[行数]\[列数\] = { {数据1，数据2 } ，{数据3，数据4 },...... };

数据类型 数组名[行数]\[列数\] = { 数据1，数据2，数据3，数据4, ......};

数据类型 数组名[ ][列数] = { 数据1，数据2，数据3，数据4,......};

数据类型 数组名[行数]\[列数\] = { 0 };  // 把全部的元素初始化为0。

数据类型 数组名[行数]\[列数\] = { };   // 把全部的元素初始化为0。

注意：如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。如果想把数组中全部的元素初始化为0，可以在{}内只填一个0或什么也不填。

C++11标准可以不写等于号。

### 5）清空二维数组

用memset()函数可以把二维数组中全部的元素清零。（只适用于C++基本数据类型）

函数原型：void *memset(void *s, int c, size_t n);

注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>

### 6）复制二维数组

用memcpy()函数可以把二维数组中全部的元素复制到另一个相同大小的数组（没说多少维）。（只适用于C++基本数据类型）

函数原型：void *memcpy(void *dest, const void *src, size_t n);

注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>

## 8.二维数组用于函数的参数

这里我们会提及行指针的概念，只不过行指针的应用场景少，主要是二维数组向函数传递地址

### 1）行指针（数组指针）

声明行指针的语法：数据类型 (*行指针名)[行的大小];  // 行的大小即数组长度。

这里加括号是因为，如果不加括号，下标运算符[]的优先级是最高的，这样就变成了指针数组，元素是一些指针

行指针与函数指针类似，如果一维数组的数据类型和数组长度不同，就会对应不同的行指针

int (*p1)[3];  // p1是行指针，用于指向数组长度为3的int型数组。

int (*p2)[5];  // p2行指针，用于指向数组长度为5的int型数组。

double (*p3)[5];  // p3是行指针，用于指向数组长度为5的double型数组。

一维数组名被解释为数组第0个元素的地址。

对一维数组名取地址得到的是数组的地址，是行地址。

### 2）二维数组名是行地址

int bh[2][3] = { {11,12,13},{21,22,23} };

bh是二维数组名，该数组有两个元素，每一个元素本身又是一个数组长度为3的整型数组。

bh被解释为数组长度为3的整型数组类型的行地址。

如果存放bh的值，要用数组长度为3的整型数组类型的行指针。

int (*p)[3]=bh;

int bh[4][2][3];

bh是三维数组名，该数组有4元素，每一个元素本身又是一个2行3列的二维数组。

bh被解释为2行3列的二维数组类型的二维地址。

如果存放bh的值，要用2行3列的二维数组类型的二维指针。

int (*p)[2][3]=bh;

### 3）把二维数组传递给函数

如果要把bh传给函数，函数的声明如下：

void func(int (*p)[3],int len);

void func(int p[][3],int len);

# 十八、结构体、共同体和枚举

## 1.结构体基本概念

结构体是用户自定义的类型，可以将多种数据的表示合并到一起，描述一个完整的对象。就好比说本来有一堆零散的工具（一堆分散的变量），我使用一个工具箱（也就是结构体）将其存储合并，然后就可以通过工具箱来更方便的使用这些工具

使用结构体有两个步骤：1）定义结构体描述（类型）；2）创建结构体变量。

### 1）定义结构体描述

定义结构体描述的语法：

struct 结构体名

{

成员一的数据类型  成员名一;

成员二的数据类型  成员名二;

成员三的数据类型  成员名三;

......

成员n的数据类型  成员名n;

};

注意：

- 结构体后面是以分号结尾
- 结构体名是标识符。
- 结构体的成员可以是任意数据类型。
- 定义结构体描述的代码可以放在程序的任何地方，一般放在main函数的上面或头文件中。
- 结构体成员可以用C++的类（如string），但是不提倡。
- 在C++中，结构体中可以有函数，但是不提倡。
- 在C++11中，定义结构体的时候可以指定缺省值。

### 2）创建结构体变量

创建结构体变量的语法：

struct 结构体名 结构体变量名;

也可以直接使用结构体名创建

也可以为结构体成员赋初始值。

结构体名 结构体变量名={成员一的值, 成员二的值,......, 成员n的值};

C++11可以不写等于号。

如果大括号内未包含任何东西或只写一个0，全部的成员都将被设置为0。

struct 结构体名 结构体变量名={0};

注意：

- 在C++中，struct关键字可以不写。
- 可以在定义结构体的时候创建结构体变量。

### 3）使用结构体

在C++程序中，用成员运算符（.）来访问结构体的每个成员。结构体中的每个成员具备普通变量的全部特征。

语法：结构体变量名.结构体成员名;

### 4）占用内存的大小

用sizeof运算符可以得到整个结构体占用内存的大小。

注意：整个结构体占用内存的大小不一定等于全部成员占用内存之和，

内存对齐：#pragma pack(字节数)

合理使用内存对齐规则，某些节省内存的做法可能毫无意义。

### 5）清空结构体

创建的结构体变量如果没有初始化，成员中有垃圾值。

用memset()函数可以把结构体中全部的成员清零。（只适用于C++基本数据类型）

bzero()函数也可以。

### 6）复制结构体

用memcpy()函数把结构体中全部的元素复制到另一个相同类型的结构体（只适用于C++基本数据类型）。

也可以直接用等于号（只适用于C++基本数据类型）。

## 2.结构体指针

结构体是一种自定义的数据类型，用结构体可以创建结构体变量。是变量就会有地址，有地址就需要有指针，使用指针存放地址的值

### 1）基本语法

在C++中，用不同类型的指针存放不同类型变量的地址，这一规则也适用于结构体。如下：

```c++
struct st_girl girl;     // 声明结构体变量girl。
struct st_girl *pst=&girl;  // 声明结构体指针，指向结构体变量girls。
```

通过结构体指针访问结构体成员，有两种方法：

 (\*指针名).成员变量名   // ` (*pst).name和(*pst).age `

或者：

指针名->成员变量名   //` pst->name和pst->age `

在第一种方法中，圆点.的优先级高于*，(*指针名)两边的括号不能少。如果去掉括号写成\*指针名.成员变量名，那么相当于\*(指针名.成员变量名)，意义就完全不一样了。

在第二种方法中，`->`是一个新的运算符。

上面的两种方法是等效的，程序员通常采用第二种方法，更直观。

注意：与数组不一样，结构体变量名没有被解释为地址。

### 2）用于函数的参

如果要把结构体传递给函数，实参取结构体变量的地址，函数的形参用结构体指针。

如果不希望在函数中修改结构体变量的值，可以对形参加const约束。

### 3）用于动态分配内存

用结构体指针指向动态分配的内存的地址。

## 3.结构体数组与嵌套结构体

结构体也可以组成数组，声明方法和初始化方法与一维数组一致，并且结构体中也可以嵌套另一个结构体

```
```

## 4.结构体中的指针

如果结构体中的指针指向的是动态分配的内存地址：

对结构体用sizeof运算可能没有意义。

对结构体用memset()函数可能会造成内存泄露。

这是因为，在C++中，使用指针跟踪动态分配的内存，如果想 使用这块内存就只能使用这个指针，如果指针清零，就无法找到内存的地址，从而导致内存没有被释放造成内存泄漏

C++的字符串string中有一个指针，指向了动态分配内存的地址。

## 5.共同体

共同体（共用体、联合体）是一种数据格式，它能存储不同的数据类型，但是，在同一时间只能存储其中的一种类型。

声明共同体的语法：

union 共同体名

{

成员一的数据类型  成员名一;

成员二的数据类型  成员名二;

成员三的数据类型  成员名三;

......

成员n的数据类型  成员名n;

};

注意：

l 共同体占用内存的大小是它最大的成员占用内存的大小（内存对齐到8的整数倍）。

l 全部的成员使用同一块内存。

l 共同体中的值为最后被赋值的那个成员的值。

l 匿名共同体没有名字，可以在定义的时候创建匿名共同体变量（VS和Linux有差别），也可以嵌入结构体中。

应用场景：

l 当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间（嵌入式系统）。

l 用于回调函数的参数（相当于支持多种数据类型）。

## 6.枚举

枚举是一种创建符号常量的方法。

枚举的语法：

enum 枚举名 { 枚举量1 , 枚举量2 , 枚举量3, ......, 枚举量n };

例如：

```c++
enum colors { red , yellow , blue };
```

这条语句完成了两项工作：

l 让colors成了一种新的枚举类型的名称，可以用它创建枚举变量。

l 将red、yellow、blue作为符号常量，默认值是整数的0、1、2。

注意：

l 用枚举创建的变量取值只能在枚举量范围之内。

l 枚举的作用域与变量的作用域相同。

l 可以显式的设置枚举量的值（必须是整数）。

enum colors {red=1,yellow=2,blue=3};

l 可以只显式的指定某些枚举量的值（枚举量的值可以重复）。

enum colors {red=10,yellow,blue};

l 可以将整数强制转换成枚举量，语法：枚举类型(整数)

# 十九、引用

## 1.基本概念

引用变量是C++新增的复合类型。

引用是已定义的变量的别名（或者说给已经定义的变量取另一个名字）。

引用的主要用途是用作函数的形参和返回值。

声明/创建引用的语法：数据类型 &引用名=原变量名;

```c++
int a=3;
int &ra=a;
```

注意：

- 引用的数据类型要与原变量名的数据类型相同。
- 引用名和原变量名可以互换，它们值和内存单元是相同的。
- 必须在声明引用的时候初始化，初始化后不可改变。
- C和C++用&符号来指示/取变量的地址，C++给&符号赋予了另一种含义。

## 2.引用的本质

引用是指针常量的伪装。

引用是编译器提供的一个有用且安全的工具，去除了指针的一些缺点，禁止了部分不安全的操作。

变量是什么？变量就是一个在程序执行过程中可以改变的量。

换一个角度，变量是一块内存区域的名字，它代表了这块内存区域，当我们对变量进行修改的时候，会引起内存区域中内容的改变。

在计算机看来，内存区域根本就不存在什么名字，它仅有的标志就是它的地址，因此我们若想修改一块内存区域的内容，只有知道他的地址才能实现。

所谓的变量只不过是编译器给我们进行的一种抽象，让我们不必去了解更多的细节，降低我们的思维跨度而已。

程序员拥有引用，但编译器仅拥有指针（地址）。

引用的底层机制实际上是和指针一样的。不要相信有别名，不要认为引用可以节省一个指针的空间，因为这一切不会发生，编译器还是会把引用解释为指针。

引用和指针本质上没有区别。

## 3.引用用于函数参数

把函数的形参声明为引用，调用函数的时候，形参将成为实参的别名，在函数中修改形参会影响函数外实参的值

这种方法也叫按引用传递或传引用。（传值、传地址、传引用只是说法不同，其实都是传值。）

引用的本质是指针，传递的是变量的地址，在函数中，修改形参会影响实参。

1）传引用的代码更简洁。

2）传引用不必使用二级指针。

3）引用的属性和特别之处。

## 4.引用的形参和const

如果引用的数据对象类型不匹配，当引用为const时，C++将创建临时变量，让引用指向临时变量。

什么时候将创建临时变量呢？

- 引用是const。
  - 数据对象的类型是正确的，但不是左值。比如说一个是变量，一个是具体的值或者数据，例如`const int& ra=8`
- 数据对象的类型不正确，但可以转换为正确的类型。比如说形参为`int`但是传入是`char`的一个值

结论：如果函数的实参不是左值或与const引用形参的类型不匹配，那么C++将创建正确类型的匿名变量，将实参的值传递给匿名变量，并让形参来引用该变量。

将引用形参声明为const的理由有三个：

- 使用const可以避免无意中修改数据的编程错误。
- 使用const使函数能够处理const和非const实参，否则将只能接受非const实参。
- 使用const，函数能正确生成并使用临时变量。

左值是可以被引用的数据对象，可以通过地址访问它们，例如：变量、数组元素、结构体成员、引用和解引用的指针。

非左值包括字面常量（用双引号包含的字符串除外）和包含多项的表达式。

## 5.引用用于函数的返回值

传统的函数返回机制与值传递类似。

函数的返回值被拷贝到一个临时位置（寄存器或栈），然后调用者程序再使用这个值。

```c++
double m=sqrt(36);    // sqrt()是求平方根函数。
//sqrt(36)的返回值6被拷贝到临时的位置，然后赋值给m。
cout << sqrt(25);
//sqrt(25)的返回值5被拷贝到临时的位置，然后传递给cout
```

如果返回的是一个结构体，将把整个结构体拷贝到临时的位置。

如果返回引用不会拷贝内存，可以节省空间和时间

语法：

返回值的数据类型& 函数名(形参列表);

注意：

- 如果返回局部变量的引用，其本质是野指针，后果不可预知。
- 可以返回函数的引用形参、类的成员、全局变量、静态变量。
- 返回引用的函数是被引用的变量的别名，将const用于引用的返回类型。

# 二十、函数重载

## 1默认参数

默认参数是指调用函数的时候，如果不书写实参，那么将使用的一个缺省值。

语法：返回值 函数名(数据类型 参数=值, 数据类型 参数=值,……);

注意：

- 如果函数的声明和定义是分开书写的，在函数声明中书写默认参数，函数的定义中不能书写默认参数。
- 函数必须从右到左设置默认参数。也就是说，如果要为某个参数设置默认值，则必须为它后面所有的参数设置默认值。
- 调用函数的时候，如果指定了某个参数的值，那么该参数前面所有的参数都必须指定。

## 2重载的基本概念

函数重载（函数多态）是指设计一系列同名函数，让它们完成相同（似）的工作。

C++允许定义名称相同的函数，条件是它们的特征（形参的个数、数据类型和排列顺序）不同。

```c++
int func(short a  ,string b);
int func(int a   ,string b);
int func(double a,string b);
int func(int a   ,string b, int len);
int func(string b , int a);
```

调用重载函数的时候，在代码中我们用相同的函数名，但是，后面的实参不一样，编译器根据实参与重载函数的形参进行匹配，然后决定调用具体的函数，如果匹配失败，编译器将视为错误。

在实际开发中，视需求重载各种数据类型，不要重载功能不同的函数。

注意：

- 使用重载函数时，如果数据类型不匹配，C++尝试使用类型转换与形参进行匹配，如果转换后有多个函数能匹配上，编译将报错。
- 引用可以作为函数重载的条件，但是，调用重载函数的时候，如果实参是变量，编译器将形参类型的本身和类型引用视为同一特征。
- 如果重载函数有默认参数，调用函数时，可能导致匹配失败。
- const不能作为函数重载的特征。
- 返回值的数据类型不同不能作为函数重载的特征。
- C++的名称修饰：编译时，对每个函数名进行加密，替换成不同名的函数。

```c++
void MyFunctionFoo(int,float);
void MyFunctionFoo(long,float);
?MyFunctionFoo@@YAXH(int,float);
\#void MyFunctionFoo^$@(long,float);
```



